-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://redmine.postgresql.org/projects/pgadmin4/issues/new if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.active_acc
(
    active_id SERIAL NOT NULL,
    admin_acc_id integer NOT NULL,
    status boolean NOT NULL DEFAULT true,
    CONSTRAINT active_acc_pk PRIMARY KEY (active_id)
);

COMMENT ON TABLE public.active_acc
    IS 'this holds the active accounts by admins';

CREATE TABLE IF NOT EXISTS public.admin_acc
(
    id SERIAL NOT NULL,
    username character varying COLLATE pg_catalog."default" NOT NULL,
    email character varying COLLATE pg_catalog."default" NOT NULL,
    password character varying COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT admin_acc_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.admin_details
(
    id SERIAL NOT NULL,
    first_name character varying COLLATE pg_catalog."default",
    last_name character varying COLLATE pg_catalog."default",
    email character varying COLLATE pg_catalog."default",
    phone_no character varying COLLATE pg_catalog."default",
    alt_phone_no character varying COLLATE pg_catalog."default",
    alt_email character varying COLLATE pg_catalog."default",
    admin_id bigint NOT NULL,
    CONSTRAINT admin_details_pkey PRIMARY KEY (id),
    CONSTRAINT unique_admin_id UNIQUE (admin_id)
);

CREATE TABLE IF NOT EXISTS public.avg_rating
(
    avg bigint
);

CREATE TABLE IF NOT EXISTS public.booking
(
    id SERIAL NOT NULL,
    checkin datemultirange NOT NULL,
    checkout datemultirange NOT NULL,
    rooms bigint NOT NULL,
    adults bigint NOT NULL DEFAULT 1,
    children bigint DEFAULT 0,
    hotel_id bigint NOT NULL,
    order_time timestamp without time zone NOT NULL DEFAULT now(),
    user_name character varying COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT booking_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.comments
(
    id SERIAL NOT NULL,
    username character varying COLLATE pg_catalog."default" NOT NULL,
    rating bigint NOT NULL,
    comment character varying COLLATE pg_catalog."default",
    hotel_id bigint NOT NULL,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    CONSTRAINT comments_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.hotel
(
    id SERIAL NOT NULL,
    name character varying COLLATE pg_catalog."default" NOT NULL,
    location character varying COLLATE pg_catalog."default" NOT NULL,
    description character varying COLLATE pg_catalog."default" NOT NULL,
    pricing double precision NOT NULL,
    no_of_beds bigint,
    no_of_rooms bigint,
    longitude double precision,
    latitude double precision,
    place character varying COLLATE pg_catalog."default",
    admin_id bigint NOT NULL,
    CONSTRAINT hotel_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.hotel_images
(
    id SERIAL NOT NULL,
    imageurl character varying COLLATE pg_catalog."default" NOT NULL,
    description character varying COLLATE pg_catalog."default",
    hotel_id bigint NOT NULL,
    public_id character varying COLLATE pg_catalog."default",
    CONSTRAINT hotel_images_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.hotel_services
(
    id SERIAL NOT NULL,
    views boolean DEFAULT false,
    entertainment boolean DEFAULT false,
    parking boolean DEFAULT false,
    washing_machine boolean DEFAULT false,
    swimming boolean DEFAULT false,
    wifi boolean DEFAULT false,
    bar boolean DEFAULT false,
    breakfast boolean DEFAULT false,
    fitness_centre boolean DEFAULT false,
    restaurant boolean DEFAULT false,
    room_services boolean DEFAULT false,
    hotel_id bigint NOT NULL,
    CONSTRAINT hotel_services_pkey PRIMARY KEY (id),
    CONSTRAINT unique_hotel_id UNIQUE (hotel_id)
        INCLUDE(hotel_id)
);

CREATE TABLE IF NOT EXISTS public.user_account
(
    id SERIAL NOT NULL,
    username character varying COLLATE pg_catalog."default" NOT NULL,
    email character varying COLLATE pg_catalog."default" NOT NULL,
    password character varying COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT user_account_pkey PRIMARY KEY (id),
    CONSTRAINT unique_email UNIQUE (email),
    CONSTRAINT unique_username UNIQUE (username)
);

CREATE TABLE IF NOT EXISTS public.user_details
(
    id SERIAL NOT NULL,
    first_name character varying COLLATE pg_catalog."default",
    last_name character varying COLLATE pg_catalog."default",
    email character varying COLLATE pg_catalog."default" NOT NULL,
    username character varying COLLATE pg_catalog."default" NOT NULL,
    phone_no character varying COLLATE pg_catalog."default",
    user_account_id bigint NOT NULL,
    CONSTRAINT user_details_pkey PRIMARY KEY (id),
    CONSTRAINT unique_fkey UNIQUE (user_account_id)
        DEFERRABLE,
    CONSTRAINT unique_id UNIQUE (user_account_id)
);

ALTER TABLE IF EXISTS public.active_acc
    ADD CONSTRAINT active_acc_admin_acc_id_fk FOREIGN KEY (admin_acc_id)
    REFERENCES public.admin_acc (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.admin_details
    ADD CONSTRAINT admin_details_fkey FOREIGN KEY (admin_id)
    REFERENCES public.admin_acc (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;
CREATE INDEX IF NOT EXISTS unique_admin_id
    ON public.admin_details(admin_id);


ALTER TABLE IF EXISTS public.booking
    ADD CONSTRAINT booking_fk FOREIGN KEY (user_name)
    REFERENCES public.user_account (username) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.hotel
    ADD CONSTRAINT admin_fkey FOREIGN KEY (admin_id)
    REFERENCES public.admin_acc (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS public.hotel_images
    ADD CONSTRAINT image_fkey FOREIGN KEY (hotel_id)
    REFERENCES public.hotel (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS public.hotel_services
    ADD CONSTRAINT services_fkey FOREIGN KEY (hotel_id)
    REFERENCES public.hotel (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;
CREATE INDEX IF NOT EXISTS unique_hotel_id
    ON public.hotel_services(hotel_id);


ALTER TABLE IF EXISTS public.user_details
    ADD CONSTRAINT f_key FOREIGN KEY (user_account_id)
    REFERENCES public.user_account (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;
CREATE INDEX IF NOT EXISTS unique_id
    ON public.user_details(user_account_id);

CREATE OR REPLACE FUNCTION public.check_admin_credentials(
	in_credentials character varying)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.admin_acc
        WHERE username = in_credentials
           OR email = in_credentials
    );
END;
$BODY$;

CREATE OR REPLACE FUNCTION public.create_admin_and_hotel(
	admin_username character varying,
	admin_email character varying,
	admin_password character varying,
	admin_first_name character varying,
	admin_last_name character varying,
	admin_phone_no character varying,
	hotel_name character varying,
	hotel_location character varying,
	hotel_place character varying,
	hotel_description character varying,
	hotel_pricing double precision,
	hotel_no_of_beds bigint,
	hotel_no_of_rooms bigint,
	hotel_longitude double precision,
	hotel_latitude double precision,
	alt_admin_phone_no character varying DEFAULT NULL::character varying,
	alt_admin_email character varying DEFAULT NULL::character varying)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    admin_account_id_out bigint;
    hotel_id_out bigint;
BEGIN
    -- CREATE ADMIN ACCOUNT FIRST
    -- Insert Admin details into admin account first
    INSERT INTO public.admin_acc(username, email, password)
    VALUES (admin_username, admin_email, admin_password)
    RETURNING id INTO admin_account_id_out;

    -- ADD ADMIN DETAILS
    -- Second, insert admin details
    INSERT INTO public.admin_details(first_name, last_name, email, phone_no, alt_phone_no, alt_email, admin_id)
    VALUES (admin_first_name, admin_last_name, admin_email, admin_phone_no, alt_admin_phone_no, alt_admin_email, admin_account_id_out);

    -- CREATE HOTEL
    -- Insert hotel details third
    INSERT INTO public.hotel(name, location, description, pricing, no_of_beds, no_of_rooms, longitude, admin_id, latitude, place)
    VALUES (hotel_name, hotel_location, hotel_description, hotel_pricing, hotel_no_of_beds, hotel_no_of_rooms, hotel_longitude, admin_account_id_out, hotel_latitude, hotel_place)
    RETURNING id INTO hotel_id_out;
    -- create hotel services and insert into them by default false
    insert into public.hotel_services(views, entertainment, parking, washing_machine, swimming, wifi, bar, breakfast, fitness_centre, restaurant, room_services, hotel_id)
    values (false,false,false,false,false,false,false,false,false,false,false,hotel_id_out);

    RETURN hotel_id_out;
END;
$BODY$;


CREATE OR REPLACE FUNCTION public.create_hotel(
	hotel_admin_id bigint,
	hotel_name character varying,
	hotel_location character varying,
	hotel_description character varying,
	hotel_pricing double precision,
	hotel_beds_no bigint,
	hotel_no_of_rooms bigint,
	hotel_place character varying,
	hotel_longitude double precision DEFAULT NULL::double precision,
	hotel_latitude double precision DEFAULT NULL::double precision,
	h_views boolean DEFAULT false,
	h_entertainment boolean DEFAULT false,
	h_parking boolean DEFAULT false,
	h_washing_machine boolean DEFAULT false,
	h_swimming boolean DEFAULT false,
	h_wifi boolean DEFAULT false,
	h_bar boolean DEFAULT false,
	h_breakfast boolean DEFAULT false,
	h_fitness_centre boolean DEFAULT false,
	h_restaurant boolean DEFAULT false,
	h_room_services boolean DEFAULT false)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
declare
    hotel_id_out bigint;
begin
    -----------create hotel-------------
    insert into public.hotel(name, location, description, pricing, no_of_beds, no_of_rooms, longitude, latitude, place, admin_id) VALUES
    (hotel_name,hotel_location,hotel_description,hotel_pricing,hotel_beds_no,hotel_no_of_rooms,hotel_longitude,hotel_latitude,hotel_place,hotel_admin_id) returning id into hotel_id_out;
    ------------create hotel services----------
    insert into public.hotel_services(views, entertainment, parking, washing_machine, swimming, wifi, bar, breakfast, fitness_centre, restaurant, room_services, hotel_id)
    values (h_views,h_entertainment,h_parking,h_washing_machine,h_swimming,h_wifi,h_bar,h_breakfast,h_fitness_centre,h_restaurant,h_room_services,hotel_id_out);
    return hotel_id_out;
    end;
$BODY$;

	
CREATE OR REPLACE FUNCTION public.get_admin_credentials(
	credentials character varying)
    RETURNS TABLE(admin_username character varying, admin_email character varying, admin_password character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    -- Check if the admin exists
    IF NOT EXISTS (
        SELECT 1
        FROM public.admin_acc
        WHERE username = credentials
        OR email = credentials
    ) THEN
        RAISE EXCEPTION 'Admin not found.';
    END IF;
    
    RETURN QUERY
        SELECT email, username, password
        FROM public.admin_acc
        WHERE username = credentials
        OR email = credentials;
END;
$BODY$;



CREATE OR REPLACE FUNCTION public.get_all_hotel_details(
	in_hotel_id integer)
    RETURNS TABLE(id integer, name character varying, location character varying, description character varying, pricing double precision, no_of_beds bigint, no_of_rooms bigint, longitude double precision, latitude double precision, place character varying, view boolean, entertainment boolean, parking boolean, washing_machine boolean, swimming boolean, wifi boolean, bar boolean, breakfast boolean, fitness_centre boolean, restaurant boolean, room_service boolean) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
BEGIN
    return query
        SELECT h.id,h.name,h.location,h.description,h.pricing,
               h.no_of_beds,h.no_of_rooms,h.longitude,h.latitude,h.place,
               hs.views, hs.entertainment, hs.parking, hs.washing_machine, hs.swimming,
               hs.wifi, hs.bar, hs.breakfast, hs.fitness_centre, hs.restaurant, hs.room_services from public.hotel h
            left join hotel_services hs on h.id = hs.hotel_id where h.id = in_hotel_id
    ;
end;
$BODY$;


CREATE OR REPLACE FUNCTION public.get_hotel_comments(
	in_hotel_id integer)
    RETURNS TABLE(user_username character varying, hotel_rating bigint, user_comment character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    BEGIN
        RETURN QUERY
        SELECT username,rating,comment
        from public.comments where hotel_id = in_hotel_id;
    END;

$BODY$;


CREATE OR REPLACE FUNCTION public.get_hotels_by_location_or_admin_or_id(
	in_location character varying,
	in_admin_username character varying,
	in_hotel_id integer)
    RETURNS TABLE(primary_hotel_id integer, hotel_name character varying, hotel_location character varying, hotel_description character varying, hotel_pricing double precision, hotel_no_of_beds bigint, hotel_no_of_rooms bigint, hotel_longitude double precision, hotel_latitude double precision, hotel_place character varying, hotel_rating bigint) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
    hotel_count integer;
    avg_rating bigint;
BEGIN
    IF in_location IS NOT NULL THEN
        SELECT COUNT(*) INTO hotel_count
        FROM public.hotel
        WHERE location = in_location;

        SELECT AVG(rating)::bigint INTO avg_rating
        FROM comments
        WHERE hotel_id IN (
            SELECT hotel_id
            FROM public.hotel
            WHERE location = in_location
        );

        RETURN QUERY
            SELECT id, name, location, description,
                   pricing, no_of_beds, no_of_rooms,
                   longitude, latitude, place, avg_rating AS hotel_rating
            FROM public.hotel
            WHERE location = in_location;
    ELSIF in_admin_username IS NOT NULL THEN
        SELECT COUNT(*) INTO hotel_count
        FROM public.hotel
        WHERE admin_id IN(SELECT id FROM public.admin_acc WHERE username = in_admin_username);

        SELECT AVG(rating)::bigint INTO avg_rating
        FROM comments
        WHERE hotel_id IN (
            SELECT hotel_id
            FROM public.hotel
            WHERE admin_id IN(SELECT id FROM public.admin_acc WHERE username = in_admin_username)
        );

        RETURN QUERY
            SELECT id, name, location, description,
                   pricing, no_of_beds, no_of_rooms,
                   longitude, latitude, place, avg_rating AS hotel_rating
            FROM public.hotel
            WHERE admin_id IN(SELECT id FROM public.admin_acc WHERE username = in_admin_username);
    ELSIF in_hotel_id IS NOT NULL THEN
        SELECT COUNT(*) INTO hotel_count
        FROM public.hotel
        WHERE id = in_hotel_id;

        SELECT AVG(rating)::bigint INTO avg_rating
        FROM comments
        WHERE hotel_id = in_hotel_id;

        RETURN QUERY
            SELECT id, name, location, description,
                   pricing, no_of_beds, no_of_rooms,
                   longitude, latitude, place, avg_rating AS hotel_rating
            FROM public.hotel
            WHERE id = in_hotel_id;
    END IF;
END;
$BODY$;



CREATE OR REPLACE FUNCTION public.get_user_credentials(
	credentials character varying)
    RETURNS TABLE(user_email character varying, user_username character varying, user_password character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    -- Check if the user exists
    IF NOT EXISTS (
        SELECT 1
        FROM public.user_account
        WHERE username = credentials
        OR email = credentials
    ) THEN
        RAISE EXCEPTION 'User not found.';
    END IF;
    
    RETURN QUERY
        SELECT email, username, password
        FROM public.user_account
        WHERE username = credentials
        OR email = credentials;
END;
$BODY$;

	
CREATE OR REPLACE PROCEDURE public.insert_user_record(
	IN p_full_name character varying,
	IN p_password character varying,
	IN p_email character varying,
	IN p_username character varying)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    user_id integer;
    p_first_name character varying;
    p_last_name character varying;
BEGIN
    -- Check if the username is taken
    IF EXISTS (SELECT 1 FROM public.user_account WHERE username = p_username) THEN
        RAISE SQLSTATE '23505' USING MESSAGE = 'Username is already taken.';
    END IF;

    -- Check if the email is registered
    IF EXISTS (SELECT 1 FROM public.user_account WHERE email = p_email) THEN
        RAISE SQLSTATE '23505' USING MESSAGE = 'Email is already registered.';
    END IF;

    -- Insert into user_account table
    INSERT INTO public.user_account (password, email, username)
    VALUES (p_password, p_email, p_username)
    RETURNING id INTO user_id;

    -- Split the name into first name and last name
    SELECT SPLIT_PART(p_full_name, ' ', 1) INTO p_first_name;
    SELECT SPLIT_PART(p_full_name, ' ', 2) INTO p_last_name;

    -- Insert details into user_details table
    INSERT INTO public.user_details (id, first_name, last_name, email, username, user_account_id)
    VALUES (user_id, p_first_name, p_last_name, p_email, p_username, user_id);
END;
$BODY$;

	
END;